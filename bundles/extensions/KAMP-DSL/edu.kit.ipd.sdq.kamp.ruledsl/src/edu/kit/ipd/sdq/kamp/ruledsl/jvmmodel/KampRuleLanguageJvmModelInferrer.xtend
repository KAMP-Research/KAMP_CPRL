/*
 * generated by Xtext 2.10.0
 */
package edu.kit.ipd.sdq.kamp.ruledsl.jvmmodel

import com.google.inject.Inject
import edu.kit.ipd.sdq.kamp.architecture.AbstractArchitectureVersion
import edu.kit.ipd.sdq.kamp.model.modificationmarks.AbstractModificationRepository
import edu.kit.ipd.sdq.kamp.ruledsl.kampRuleLanguage.BackwardEReference
import edu.kit.ipd.sdq.kamp.ruledsl.kampRuleLanguage.Block
import edu.kit.ipd.sdq.kamp.ruledsl.kampRuleLanguage.CausingEntityMarker
import edu.kit.ipd.sdq.kamp.ruledsl.kampRuleLanguage.ForwardEReference
import edu.kit.ipd.sdq.kamp.ruledsl.kampRuleLanguage.Instruction
import edu.kit.ipd.sdq.kamp.ruledsl.kampRuleLanguage.KampRule
import edu.kit.ipd.sdq.kamp.ruledsl.kampRuleLanguage.Lookup
import edu.kit.ipd.sdq.kamp.ruledsl.kampRuleLanguage.RecursiveBlock
import edu.kit.ipd.sdq.kamp.ruledsl.kampRuleLanguage.RuleFile
import edu.kit.ipd.sdq.kamp.ruledsl.kampRuleLanguage.RuleReference
import edu.kit.ipd.sdq.kamp.ruledsl.kampRuleLanguage.StandardBlock
import edu.kit.ipd.sdq.kamp.ruledsl.support.CausingEntityMapping
import edu.kit.ipd.sdq.kamp.ruledsl.support.ChangePropagationStepRegistry
import edu.kit.ipd.sdq.kamp.ruledsl.support.IRecursiveRule
import edu.kit.ipd.sdq.kamp.ruledsl.support.IRule
import edu.kit.ipd.sdq.kamp.ruledsl.util.EcoreUtil
import edu.kit.ipd.sdq.kamp.ruledsl.util.ErrorHandlingUtil
import edu.kit.ipd.sdq.kamp.util.LookupUtil
import java.util.ArrayList
import java.util.HashMap
import java.util.List
import java.util.Map
import java.util.concurrent.atomic.AtomicInteger
import java.util.stream.Stream
import org.eclipse.emf.common.util.BasicEList
import org.eclipse.emf.common.util.EList
import org.eclipse.emf.ecore.EObject
import org.eclipse.jface.dialogs.ErrorDialog
import org.eclipse.swt.widgets.Shell
import org.eclipse.ui.PlatformUI
import org.eclipse.xtend2.lib.StringConcatenationClient
import org.eclipse.xtext.common.types.JvmDeclaredType
import org.eclipse.xtext.common.types.JvmGenericType
import org.eclipse.xtext.common.types.JvmTypeReference
import org.eclipse.xtext.xbase.jvmmodel.AbstractModelInferrer
import org.eclipse.xtext.xbase.jvmmodel.IJvmDeclaredTypeAcceptor
import org.eclipse.xtext.xbase.jvmmodel.JvmTypesBuilder
import org.osgi.framework.FrameworkUtil

import static edu.kit.ipd.sdq.kamp.ruledsl.util.EcoreUtil.*

import static extension edu.kit.ipd.sdq.kamp.ruledsl.util.KampRuleLanguageEcoreUtil.*

/**
 * <p>Infers a JVM model from the source model.</p> 
 *
 * <p>The JVM model should contain all elements that would appear in the Java code 
 * which is generated from the source model. Other models link against the JVM model rather than the source model.</p>     
 */
class KampRuleLanguageJvmModelInferrer extends AbstractModelInferrer {

	/**
	 * convenience API to build and initialize JVM types and their members.
	 */
	@Inject extension JvmTypesBuilder
	

	/** associates a variable name with a {@link Lookup} */
	private Map<Lookup, String> nameForLookup;
	
	/** track the index of the currently inserted rule */
	private AtomicInteger currentRuleIndex = new AtomicInteger();
	
	/**
	 * The dispatch method {@code infer} is called for each instance of the
	 * given element's type that is contained in a resource.
	 * 
	 * @param element
	 *            the model to create one or more
	 *            {@link JvmDeclaredType declared
	 *            types} from.
	 * @param acceptor
	 *            each created
	 *            {@link JvmDeclaredType type}
	 *            without a container should be passed to the acceptor in order
	 *            get attached to the current resource. The acceptor's
	 *            {@link IJvmDeclaredTypeAcceptor#accept(org.eclipse.xtext.common.types.JvmDeclaredType)
	 *            accept(..)} method takes the constructed empty type for the
	 *            pre-indexing phase. This one is further initialized in the
	 *            indexing phase using the lambda you pass as the last argument.
	 * @param isPreIndexingPhase
	 *            whether the method is called in a pre-indexing phase, i.e.
	 *            when the global index is not yet fully updated. You must not
	 *            rely on linking using the index if isPreIndexingPhase is
	 *            <code>true</code>.
	 */
	def dispatch void infer(Block block, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase) {		
		if(block instanceof StandardBlock) {
			createRule(block as KampRule, acceptor, isPreIndexingPhase, -1, currentRuleIndex);
		} else if(block instanceof RecursiveBlock) {
			for(rule : block.rules) {
				createRule(rule, acceptor, isPreIndexingPhase, getBlockNumber(rule, block.eContainer as RuleFile), currentRuleIndex);
			}
		}	
	}
	
	def int getBlockNumber(KampRule rule, RuleFile ruleFile) {
		var i = -1;
		for(cStep : ruleFile.blocks) {
			if(cStep instanceof RecursiveBlock) {
				i++;
				
				if(cStep.rules.contains(rule)) {
					return i;
				}
			}
		}
		
		return -1;
	}
	
	// stepId == -1 means that it is an independent rule
	def void createRule(KampRule rule, IJvmDeclaredTypeAcceptor acceptor, boolean isPreIndexingPhase, int blockId, AtomicInteger currentRuleIndex) {
		val className = rule.getClassName();
		val clazz = rule.toClass(className);
		clazz.packageName = "gen.rule";
		
		val List<CausingEntityMarker> causingEntityMarkers = getCausingEntityMarkers(rule.instructions);
		val Map<CausingEntityMarker, Lookup> causingEntityLookups = getCausingEntityLookups(rule.instructions, causingEntityMarkers);
		var boolean hasSourceMarker = false;
		
		// determine the data type of causing elements...
		for(marker : causingEntityLookups.entrySet) {
			if(marker.value === null) {
				// this means that source was marked
				hasSourceMarker = true;
			}
		}
		
		if(causingEntityMarkers.isEmpty) {
			// if there is no marker, mark source
			hasSourceMarker = true;
		}
		
		val hasSourceMarkerFinal = hasSourceMarker;
		
		// First check if the project has the JRE on classpath
		ensureJreIsOnClasspath();
		
		acceptor.accept(clazz,
			[ theClass |
				// determine formal parameter types
				val returnType = typeRef(getReturnType(rule.lookups.last));
				val sourceType = typeRef(rule.source.metaclass.instanceTypeName);
				
				nameForLookup = newHashMap
				
				// create fields, setters and getters
				theClass.members += rule.toField("architectureVersion", typeRef(AbstractArchitectureVersion, typeRef(AbstractModificationRepository, wildcard(), wildcard())));
				theClass.members += rule.toField("changePropagationStepRegistry", typeRef(ChangePropagationStepRegistry));
				theClass.members += rule.toGetter("architectureVersion", "architectureVersion", typeRef(AbstractArchitectureVersion, typeRef(AbstractModificationRepository, wildcard(), wildcard())));
				theClass.members += rule.toGetter("changePropagationStepRegistry", "changePropagationStepRegistry", typeRef(ChangePropagationStepRegistry));			
				theClass.members += rule.toSetter("architectureVersion", "architectureVersion", typeRef(AbstractArchitectureVersion, typeRef(AbstractModificationRepository, wildcard(), wildcard())))
				theClass.members += rule.toSetter("changePropagationStepRegistry", "changePropagationStepRegistry", typeRef(ChangePropagationStepRegistry))
				
				// choose correct implementing interface and add special methods
				var JvmTypeReference currentInterface = null;
				if(blockId > -1) {
					currentInterface = IRecursiveRule.typeRef(sourceType, returnType, typeRef(AbstractArchitectureVersion, typeRef(AbstractModificationRepository, wildcard(), wildcard())), typeRef(AbstractModificationRepository, wildcard(), wildcard()))
					
					val getStepIdMethod = rule.toMethod("getRecursiveBlockId", typeRef("int")) [
						body = '''
							return «blockId»;
						'''
					];
					
					getStepIdMethod.annotations += annotationRef(Override)					
					theClass.members += getStepIdMethod
				} else {
					currentInterface = IRule.typeRef(sourceType, returnType, typeRef(AbstractArchitectureVersion, typeRef(AbstractModificationRepository, wildcard(), wildcard())), typeRef(AbstractModificationRepository, wildcard(), wildcard()));
				}
				
				// add formal type parameters to implementing interface
				theClass.superTypes += currentInterface;
				
				// create the apply method
				val applyMethod = rule.toMethod(getMethodName(), typeRef("void")) [
					// parameters += rule.toParameter("version", typeRef(AbstractArchitectureVersion, wildcard()))
					// parameters += rule.toParameter("registry", typeRef(ChangePropagationStepRegistry))
					parameters += rule.toParameter("sourceElements", Stream.typeRef(typeRef(CausingEntityMapping, sourceType, typeRef(EObject))));
					
					nameForLookup.put(null, "input")
					if(rule.modificationMark !== null) {
						
						// TODO reimplement this stuff to match new return type of lookup method
						body = '''
«««							«LookupUtil».lookup(architectureVersion, «typeRef(rule.source.metaclass.instanceTypeName)».class, «rule.getClassName»::«rule.getLookupMethodName(rule.lookups.last)»)
«««								.forEach((result) -> {
«««									if(«PropagationStepUtil».isNewEntry(result, «stepId», changePropagationRegistry)) {
«««										«AbstractModification»<?, «EObject»> modificationMark = «ModificationMarkCreationUtil».createModificationMark(result, «rule.modificationMark.type.qualifiedName».eINSTANCE.«rule.modificationMark.memberRef»());
«««										«ModificationMarkCreationUtil».insertModificationMark(modificationMark, registry, «rule.modificationMark.target.qualifiedName».class, "«rule.modificationMark.targetMethod»");
«««										«PropagationStepUtil».addNewModificationMark(result, modificationMark, «stepId», changePropagationRegistry);
«««									} else {
«««										«PropagationStepUtil».addToExistingModificationMark(result, «stepId», changePropagationRegistry);
«««									}
«««								});
						'''
					} else {
						body = ''''''
					}
				];
				applyMethod.annotations += annotationRef(Override)
				theClass.members += applyMethod;
			
				// create the static lookup method
				val lookupMethodName = rule.getLookupMethodName(rule.lookups.last);
				try {
					val lookupMethod = rule.toMethod(lookupMethodName, null) [
					parameters += rule.toParameter(rule.source.metaclass.name.toFirstLower + "Mapping", typeRef(CausingEntityMapping, sourceType, typeRef(EObject)))		
					//if(rule.isVersionParameterRequired()) {	// pass it always as we would have the BiFunction declaration in the utility method of apply
						parameters += rule.toParameter("version", typeRef(AbstractArchitectureVersion, wildcard()))
					//}
	
					nameForLookup.put(null, "input")
					
					//«generateSourceMarkerParameter(hasSourceMarkerFinal, rule.source.metaclass.name.toFirstLower)»
					val StringConcatenationClient strategy = '''
								«typeRef(Stream, typeRef(CausingEntityMapping, typeRef(rule.source.metaclass.instanceClass), typeRef(EObject)))» input = «Stream».of(«rule.source.metaclass.name.toFirstLower + "Mapping"»)«IF hasSourceMarkerFinal».peek(e -> e.addCausingEntityDistinct(«rule.source.metaclass.name.toFirstLower + "Mapping"».getAffectedElement()));«ELSE»;«ENDIF»
								
								«FOR x : rule.lookups»
									«x.generateCodeForRule(theClass, isRuleMarkedForCausingEntities(x, causingEntityLookups))»
								«ENDFOR»
								
								return «nameForLookup.get(rule.lookups.last)»;
							''';

					setBody(it, strategy);
				];

				lookupMethod.returnType = Stream.typeRef(typeRef(CausingEntityMapping, returnType, typeRef(EObject)))			
				lookupMethod.static = true;
				lookupMethod.final = true;
				theClass.members += lookupMethod
				
				// create the lookup member method
				val lookupMemberMethod = rule.toMethod("lookup", null) [
					parameters += rule.toParameter("sourceElements", Stream.typeRef(typeRef(CausingEntityMapping, sourceType, typeRef(EObject))));
					
					val StringConcatenationClient strategy = '''								
								return sourceElements.flatMap(e -> «lookupMethodName»(e, architectureVersion));
							''';

					setBody(it, strategy);
				];

				lookupMemberMethod.returnType = Stream.typeRef(typeRef(CausingEntityMapping, returnType, typeRef(EObject)));
				theClass.members += lookupMemberMethod
			} catch(Exception e) {
				e.printStackTrace
				// TODO replace with proper exception handling
				System.err.println("Rule could not be created. Not fully defined? Name: " + rule.name)
			}	
			
			// create class getter methods
			val sourceElementClassGetter = rule.toMethod("getSourceElementClass", Class.typeRef(sourceType)) [
				body = '''
						return «sourceType».class;
					'''
			]
			theClass.members += sourceElementClassGetter
			
			val affectedElementClassGetter = rule.toMethod("getAffectedElementClass", Class.typeRef(returnType)) [
				body = '''
						return «returnType».class;
					'''
			]
			theClass.members += affectedElementClassGetter
			
			// create the getPosition method
			val positionMethod = rule.toMethod("getPosition", typeRef("int")) [
				body = '''
						return «currentRuleIndex.getAndIncrement() * 10»;
					'''
			]
			theClass.members += positionMethod
		]);
	}
	
	// TODO this might not be the best way to do this, but it works
	def ensureJreIsOnClasspath() {
		try {
			annotationRef(Override)
		} catch(IllegalArgumentException e) {
			e.printStackTrace;
			System.err.println("This error is probably caused by JRE not being activated for the project which contains the rules.karl file.")
			
			// show a dialog
			PlatformUI.getWorkbench().getDisplay().asyncExec(new Runnable() {
				override void run() {
					val Shell shell = PlatformUI.getWorkbench().getDisplay().getActiveShell();
					ErrorDialog.openError(shell, "Error", "The JRE is not on classpath. You must convert the KAMP project to a Java Plugin Project!", ErrorHandlingUtil.createMultiStatus(FrameworkUtil.getBundle(KampRuleLanguageJvmModelInferrer).getSymbolicName(), e.getLocalizedMessage(), e));
				}
			});	
			
			return;
		}
	}
	
	def boolean isRuleMarkedForCausingEntities(Lookup lookup, Map<CausingEntityMarker, Lookup> causingEntityLookups) {
		return causingEntityLookups.containsValue(lookup)
	}
	
	def String generateSourceMarkerParameter(boolean hasSourceMarker, String parameterName) {
		return if(hasSourceMarker) parameterName else "new java.util.HashSet<>()";
	}
	
	def List<CausingEntityMarker> getCausingEntityMarkers(EList<Instruction> instructions) {
		val List<CausingEntityMarker> markers = new ArrayList();
		
		for(cInstruction : instructions) {
			if(cInstruction instanceof CausingEntityMarker) {
				markers.add(cInstruction);
			}
		}
		
		return markers;
	}
	
	def Map<CausingEntityMarker, Lookup> getCausingEntityLookups(EList<Instruction> instructions, List<CausingEntityMarker> markers) {		
		val Map<CausingEntityMarker, Lookup> lookups = new HashMap();
		if(markers.size == 0) {
			return lookups;
		}
		
		for(marker : markers) {
			lookups.put(marker, getPreviousSiblingOfType(marker, Lookup));
		}
		
		return lookups;
	}
	
	def EList<Lookup> getLookups(KampRule rule) {
		val EList<Lookup> list = new BasicEList();
		for(cInstruction : rule.instructions) {
			if(cInstruction instanceof Lookup) {
				list.add(cInstruction);
			}
		}
		
		return list;
	}
	
	def String getClassName(KampRule rule) {
		return rule.name.toFirstUpper + "Rule"
	}
	
	def Class<?> getReturnType(Lookup lastLookup) {
		if(lastLookup instanceof ForwardEReference) {
			lastLookup.metaclass.instanceClass
		} else if(lastLookup instanceof BackwardEReference) {
			lastLookup.mclass.metaclass.instanceClass
		} else if(lastLookup instanceof RuleReference) {
			lastLookup.rule.lookups.last.returnType
		} else {
			throw new UnsupportedOperationException("Missing return type determination for lookup type: " + lastLookup.class);
		}
	}
	
	def dispatch String getLookupMethodName(KampRule rule, Lookup lookup) {
		'lookup'
	}
	
	def dispatch String getLookupMethodName(KampRule rule, ForwardEReference reference) {
		'lookup' + reference.metaclass.name + 'from' + rule.source.metaclass.name
	}
	
	def dispatch String getLookupMethodName(KampRule rule, BackwardEReference reference) {
		'lookup' + reference.mclass.metaclass.name.toFirstUpper + 'from' + rule.source.metaclass.name
	}
	
	// this one is the entry point and must address the interface method which must be overridden
	def String getMethodName() {
		'''apply'''
	}
	
	/**
	 * <p>Generates the code that is embedded in the method if the given lookup
	 * is found in a chain of lookups of one rule.
	 * 
	 * <p>The rule file can be navigated using the given lookup and methods in
	 * {@link EcoreUtil}.
	 * 
	 * @param lookup the Lookup to generate the code for. There should be a
	 * dispatch method for every sub type. Otherwise the generator will throw
	 * a runtime exception.
	 * 
	 * @param typeToAddTo the class that is currently generated. Can be used to add further
	 * methods or fields with the injected extension {@link JvmTypesBuilder}.
	 */	
	def dispatch generateCodeForRule(Lookup lookup, JvmGenericType typeToAddTo, boolean addToCausingEntities) {
		'''// rule: «lookup?.toString», pre: «getPreviousSiblingOfType(lookup, Lookup)?.toString»'''
	}
	
	/**
	 * @see #generateCodeForRule(Lookup, JvmGenericType)
	 */
	def dispatch generateCodeForRule(ForwardEReference ref, JvmGenericType typeToAddTo, boolean addToCausingEntities) {
		var varName = '''marked«ref.metaclass.name.toFirstUpper»__''' + getLookupNumber(ref)
		nameForLookup.put(ref, varName)
		var String projectionClasses = null;
		if(ref.projections !== null && ref.projections.length > 0) {
			for(projection : ref.projections) {
				if(projectionClasses === null) {
					projectionClasses = projection.qualifiedName + ".class";
				} else {
					projectionClasses = projectionClasses + ", " +  projection.qualifiedName + ".class";
				}
			} 
		} else {
			projectionClasses= "null";
		}
		
		'''
			«Stream.canonicalName»<CausingEntityMapping<«ref.metaclass.instanceTypeName», EObject>> «varName» = «LookupUtil.canonicalName».lookupForwardReference(«nameForLookup.get(getPreviousSiblingOfType(ref, Lookup))», «ref.feature.many», "«ref.feature.name»", «ref.metaclass.instanceTypeName».class, «addToCausingEntities», «projectionClasses»);
		'''
	}

	/**
	 * @see #generateCodeForRule(Lookup, JvmGenericType)
	 */
	def dispatch generateCodeForRule(BackwardEReference ref, JvmGenericType typeToAddTo, boolean addToCausingEntities) {
		var varName = '''backmarked«ref.mclass.metaclass.name.toFirstUpper»__''' + getLookupNumber(ref); 
		nameForLookup.put(ref, varName)
		var String projectionClasses = null;
		if(ref.projections !== null && ref.projections.length > 0) {
			for(projection : ref.projections) {
				if(projectionClasses === null) {
					projectionClasses = projection.qualifiedName + ".class";
				} else {
					projectionClasses = projectionClasses + ", " +  projection.qualifiedName + ".class";
				}
			} 
		} else {
			projectionClasses= "null";
		}
		
		'''
			«Stream.canonicalName»<CausingEntityMapping<«ref.metaclass.instanceTypeName», EObject>> «varName» = «LookupUtil.canonicalName».lookupBackwardReference(version, «ref.mclass.metaclass.instanceTypeName».class, ''' + getFeatureName(ref) + ''', «nameForLookup.get(getPreviousSiblingOfType(ref, Lookup))», «addToCausingEntities», «projectionClasses»).stream();
		'''
	}
	
	/**
	 * @see #generateCodeForRule(Lookup, JvmGenericType)
	 */
	def dispatch generateCodeForRule(RuleReference ref, JvmGenericType typeToAddTo, boolean addToCausingEntities) {
		var varName = '''rulerefmarked«ref.metaclass.name.toFirstUpper»__''' + getLookupNumber(ref)
		nameForLookup.put(ref, varName)
		
		'''
			«Stream.canonicalName»<CausingEntityMapping<«ref.metaclass.instanceTypeName», EObject>> «varName» = «nameForLookup.get(getPreviousSiblingOfType(ref, Lookup))».flatMap(e -> «ref.rule.className».«getLookupMethodName(ref.rule, ref.rule.lookups.last)»(e, version).stream());
		'''
	}
	
	def getFeatureName(BackwardEReference reference) {
		return if(reference.feature !== null) "\"" + reference.feature.name + "\"" else null;
	}
	
	def getLookupNumber(Lookup reference) {
		val list = reference.eContainer.eContents;
		for(var int i = 0; i < list.size; i++) {
			val cRule = list.get(i);
			if(cRule.equals(reference)) {
				return i;
			}
		}
	}
	
	// we do not use this anymore because we always pass the version parameter
	def isVersionParameterRequired(KampRule rule) {
		rule.lookups.exists[r | r instanceof BackwardEReference];	
	}
}
